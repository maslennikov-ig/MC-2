# T044.5: Fix Remaining Test Failures (10 tests)

**Status**: Not Started
**Priority**: High
**Current Test Results**: 166 passing | 10 failing | 10 skipped = 186 total (89% success rate)
**Goal**: Achieve 176/176 executable tests passing (100% success rate)

---

## üìä Current Status

### Test Results Summary

```
Test Files  16 passed | 2 failed (18)
Tests  166 passed | 10 failed | 10 skipped (186)
Duration  24.66s (in thread 11.98s, 207% of CPU)
```

### Failing Tests Breakdown

#### Job Cancellation Tests (5 failures)

- `tests/integration/job-cancellation.test.ts`
  - ‚úó Scenario 1: User cancels job during processing
  - ‚úó Scenario 2: User cancels queued job
  - ‚úó Scenario 3: Non-owner tries to cancel job
  - ‚úó Scenario 4: Cannot cancel already completed job
  - ‚úó Scenario 5: Admin can cancel any job in organization

#### Worker/BullMQ Tests (5 failures)

- `tests/orchestrator/worker.test.ts`
  - ‚úó should process a test job successfully
  - ‚úó should process an initialize job successfully
  - ‚úó should handle a test job with delay
- `tests/integration/bullmq.test.ts`
  - ‚úó should handle stalled jobs gracefully
  - ‚úó should retry failed jobs

---

## üîç Root Cause Analysis

### Primary Issue: Cleanup Interference with Active Jobs

The core problem is a **fundamental conflict between test cleanup strategy and job processing lifecycle**:

```
Timeline:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Test Starts                                                     ‚îÇ
‚îÇ   ‚Üì                                                            ‚îÇ
‚îÇ Job Added (15s delay configured)                              ‚îÇ
‚îÇ   ‚Üì                                                            ‚îÇ
‚îÇ Worker Picks Up Job ‚Üí "active" event fires                   ‚îÇ
‚îÇ   ‚Üì                                                            ‚îÇ
‚îÇ Test Performs Cancellation (2-3s)                            ‚îÇ
‚îÇ   ‚Üì                                                            ‚îÇ
‚îÇ Test Completes ‚Üí afterEach() runs                            ‚îÇ
‚îÇ   ‚Üì                                                            ‚îÇ
‚îÇ obliterate({ force: true }) removes ALL jobs from Redis      ‚îÇ
‚îÇ   ‚Üì                                                            ‚îÇ
‚îÇ Worker still processing: job.updateProgress()                ‚îÇ
‚îÇ   ‚Üì                                                            ‚îÇ
‚îÇ ‚ùå Error: Missing key for job X                              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Error Messages

**Pattern 1: Missing Redis Keys**

```
Error: Missing key for job 2. updateProgress
Error: Missing key for job 2. moveToDelayed
```

**Pattern 2: Job Not Found in Database**

```
Timeout waiting for job 2 to reach DB state(s): completed.
Current state: not found in DB
```

### Technical Details

1. **BullMQ Job Lifecycle in Redis**:
   - Job added: Key created in `bull:{queue}:id` and `bull:{queue}:{jobId}`
   - Job active: Worker locks job, moves to `bull:{queue}:active`
   - Job completes: Keys removed from Redis, moved to `bull:{queue}:completed`

2. **The Cleanup Conflict**:
   - `queue.obliterate({ force: true })` immediately removes ALL keys from Redis
   - This includes jobs that are actively locked by workers
   - Worker tries to update job progress ‚Üí Redis key missing ‚Üí Error thrown

3. **Why It Happens**:
   - Tests use long delays (15s) to ensure enough time for cancellation testing
   - Test completion + cleanup happens faster than job processing
   - Worker doesn't know Redis key was forcibly removed

---

## üéØ Affected Test Files

### 1. `/tests/integration/job-cancellation.test.ts`

**Purpose**: Tests custom job cancellation mechanism that works around BullMQ's limitation (cannot cancel active/locked jobs).

**Test Strategy**:

1. User calls `jobs.cancel` tRPC endpoint
2. Endpoint sets `cancelled=true` in database
3. Job handler periodically calls `checkCancellation()`
4. If cancelled=true, handler throws `JobCancelledError`
5. Worker catches error and marks job as cancelled

**Current Issue**: Jobs with 15s delays extend beyond test completion, causing cleanup to interfere.

**Specific Errors**:

```typescript
// Scenario 1: 15s delay
delayMs: 15000,
// Test expects: Job becomes active ‚Üí cancel ‚Üí graceful stop
// Reality: Test completes ‚Üí cleanup obliterates ‚Üí worker errors

// Scenario 5: 15s delay with cancellation checks
checkCancellation: true,
// Same issue: cleanup happens before job finishes
```

### 2. `/tests/orchestrator/worker.test.ts`

**Purpose**: Unit tests for worker and job handler routing.

**Current Issue**: Uses `waitForJobStateDB()` which polls database every 250ms for up to 30s. When `obliterate()` runs, jobs disappear from both Redis and database before polling completes.

**Specific Errors**:

```typescript
// Test: should process a test job successfully
const result = await waitForJobStateDB(job.id!, ['completed', 'failed'], 25000);
// Timeout: Job never reaches completed state because cleanup removed it

// Test: should handle a test job with delay
delayMs: 1000,
// Even 1s delay can race with cleanup if worker is slow to start
```

### 3. `/tests/integration/bullmq.test.ts`

**Purpose**: Integration tests for BullMQ queue system (retries, stalled jobs, concurrent processing).

**Current Issue**: Similar to worker tests - cleanup removes jobs before assertions can verify final state.

---

## üí° Proposed Solutions

### Option A: Smart Cleanup Strategy (Recommended)

**Approach**: Modify cleanup to wait for active jobs to complete before obliterating.

**Implementation**:

```typescript
// tests/integration/job-cancellation.test.ts

afterEach(async () => {
  const queue = getQueue();

  // Step 1: Wait for all active jobs to complete
  const activeJobs = await queue.getActive();
  if (activeJobs.length > 0) {
    logger.info('Waiting for active jobs to complete before cleanup', {
      count: activeJobs.length,
      jobs: activeJobs.map(j => ({ id: j.id, state: j.getState() })),
    });

    await Promise.all(
      activeJobs.map(job =>
        job
          .waitUntilFinished(queue.queueEvents, 20000) // 20s timeout
          .catch(err => {
            logger.warn('Job did not finish cleanly', {
              jobId: job.id,
              error: err.message,
            });
          })
      )
    );
  }

  // Step 2: Now safe to obliterate
  await cleanupAllJobs(); // calls obliterate
  await cleanupJobStatusDB();
});
```

**Pros**:

- ‚úÖ Respects natural job lifecycle
- ‚úÖ No race conditions
- ‚úÖ Tests validate real-world behavior

**Cons**:

- ‚ö†Ô∏è Tests take longer (wait for 15s jobs to complete)
- ‚ö†Ô∏è More complex cleanup logic

**Estimated Impact**: Tests may take 2-3x longer (~60s total instead of ~25s)

---

### Option B: Shorter Delays with Faster Cancellation Checks

**Approach**: Reduce job delays to 2-3 seconds and increase cancellation check frequency.

**Implementation**:

```typescript
// tests/integration/job-cancellation.test.ts

// Scenario 1: Reduced from 15s ‚Üí 3s
const jobData: TestJobData = {
  jobType: JobType.TEST_JOB,
  delayMs: 3000, // 3 seconds
  checkCancellation: true,
  checkIntervalMs: 100, // Check every 100ms (new field)
  // ...
};

// Test handler: src/orchestrator/handlers/test-handler.ts
async process(job: Job<TestJobData>): Promise<JobResult> {
  const { delayMs = 0, checkCancellation = false, checkIntervalMs = 500 } = job.data;

  if (delayMs > 0 && checkCancellation) {
    const iterations = Math.floor(delayMs / checkIntervalMs);

    for (let i = 0; i < iterations; i++) {
      await this.checkCancellation(job.id!);
      await new Promise(resolve => setTimeout(resolve, checkIntervalMs));
    }
  }
  // ...
}
```

**Pros**:

- ‚úÖ Tests run faster (3s vs 15s)
- ‚úÖ Simpler cleanup logic
- ‚úÖ Frequent checks catch cancellation quickly

**Cons**:

- ‚ö†Ô∏è May not fully test real-world long-running jobs
- ‚ö†Ô∏è 3s may still race with very fast test execution

**Estimated Impact**: Tests complete in ~10-15s total

---

### Option C: Separate Test Suites

**Approach**: Split tests into fast/slow suites, run them separately.

**Structure**:

```
tests/
‚îú‚îÄ‚îÄ integration/
‚îÇ   ‚îú‚îÄ‚îÄ job-cancellation.fast.test.ts   (2-3s delays)
‚îÇ   ‚îú‚îÄ‚îÄ job-cancellation.slow.test.ts   (15-30s delays)
‚îÇ   ‚îú‚îÄ‚îÄ bullmq.fast.test.ts
‚îÇ   ‚îî‚îÄ‚îÄ bullmq.slow.test.ts
```

**CI/CD Configuration**:

```json
// package.json
{
  "scripts": {
    "test": "vitest run",
    "test:fast": "vitest run --testNamePattern='(?!.*slow)'",
    "test:slow": "vitest run --testNamePattern='slow'",
    "test:all": "pnpm test:fast && pnpm test:slow"
  }
}
```

**Pros**:

- ‚úÖ Fast feedback loop (run fast tests during development)
- ‚úÖ Comprehensive coverage (slow tests in CI)
- ‚úÖ No cleanup conflicts

**Cons**:

- ‚ö†Ô∏è More test files to maintain
- ‚ö†Ô∏è CI/CD pipeline complexity

---

### Option D: Mock Worker for Cancellation Tests

**Approach**: Use a controlled mock worker that doesn't actually process jobs asynchronously.

**Implementation**:

```typescript
// tests/integration/job-cancellation.test.ts

import { vi } from 'vitest';

describe('Job Cancellation System (with mocked worker)', () => {
  let mockWorker: any;

  beforeAll(async () => {
    // Don't start real worker
    // await startWorker(1);

    // Instead, manually control job processing
    mockWorker = {
      simulateJobStart: async (jobId: string) => {
        await createJobStatus(jobId, jobData);
        await markJobActive(jobId, 0);
      },
      simulateJobCancellation: async (jobId: string, userId: string) => {
        await markJobCancelled(jobId, userId);
      },
    };
  });

  it('should stop job gracefully when cancelled', async () => {
    const job = await addJob(JobType.TEST_JOB, jobData);

    // Manually trigger job start
    await mockWorker.simulateJobStart(job.id!);

    // Cancel the job
    const result = await callCancelJob(ctx, job.id!);

    // Manually trigger cancellation detection
    await mockWorker.simulateJobCancellation(job.id!, userId);

    // Verify database state
    const dbStatus = await getJobStatusFromDB(job.id!);
    expect(dbStatus!.cancelled).toBe(true);
  });
});
```

**Pros**:

- ‚úÖ Complete control over timing
- ‚úÖ No cleanup conflicts
- ‚úÖ Tests run very fast (<1s)

**Cons**:

- ‚ùå Not testing real worker behavior
- ‚ùå May miss integration issues
- ‚ùå Significant refactoring required

---

## üéØ Recommended Implementation Plan

### Phase 1: Quick Win (Option B + Partial A)

**Goal**: Get to 100% passing tests quickly while maintaining good coverage.

**Steps**:

1. **Reduce Job Delays** (30 min)

   ```typescript
   // job-cancellation.test.ts
   // Change all delayMs from 15000 ‚Üí 3000
   // Adjust test timeouts from 25000 ‚Üí 10000
   ```

2. **Implement Smart Cleanup** (1 hour)

   ```typescript
   // Add waitForActiveJobs() utility
   async function waitForActiveJobs(timeout = 10000): Promise<void> {
     const queue = getQueue();
     const startTime = Date.now();

     while (Date.now() - startTime < timeout) {
       const [active, delayed] = await Promise.all([queue.getActive(), queue.getDelayed()]);

       if (active.length === 0 && delayed.length === 0) {
         return; // Safe to cleanup
       }

       await new Promise(resolve => setTimeout(resolve, 250));
     }

     logger.warn('Timeout waiting for jobs to complete, forcing cleanup');
   }

   // Use in afterEach
   afterEach(async () => {
     await waitForActiveJobs(10000);
     await cleanupAllJobs();
     await cleanupJobStatusDB();
   });
   ```

3. **Add Frequent Cancellation Checks** (30 min)

   ```typescript
   // test-handler.ts
   if (checkCancellation) {
     const checkInterval = 200; // Check every 200ms
     const iterations = Math.floor(delayMs / checkInterval);

     for (let i = 0; i < iterations; i++) {
       await this.checkCancellation(job.id!);
       await new Promise(resolve => setTimeout(resolve, checkInterval));
     }
   }
   ```

**Expected Outcome**: 176/176 tests passing (100%)

---

### Phase 2: Optimization (Future Work)

1. **Implement Option C** (separate fast/slow suites)
2. **Add test performance monitoring**
3. **Document best practices for BullMQ testing**

---

## ‚úÖ Acceptance Criteria

### Must Have

- [ ] All 176 executable tests passing (100% success rate)
- [ ] 10 RLS tests properly skipped
- [ ] No "Missing key for job" errors
- [ ] No "Timeout waiting for job" errors
- [ ] Test suite completes in <60 seconds

### Nice to Have

- [ ] Test documentation updated with BullMQ testing best practices
- [ ] Smart cleanup utility extracted to shared test helpers
- [ ] Performance metrics logged for each test

---

## üìù Implementation Checklist

### Step 1: Update Test Delays

- [ ] `job-cancellation.test.ts` - Scenario 1: 15s ‚Üí 3s
- [ ] `job-cancellation.test.ts` - Scenario 2: 10s ‚Üí 3s
- [ ] `job-cancellation.test.ts` - Scenario 5: 15s ‚Üí 3s
- [ ] Adjust all test timeouts accordingly

### Step 2: Implement Smart Cleanup

- [ ] Create `waitForActiveJobs()` utility in test helpers
- [ ] Update `job-cancellation.test.ts` afterEach
- [ ] Update `worker.test.ts` afterEach
- [ ] Update `bullmq.test.ts` afterEach

### Step 3: Enhance Test Handler

- [ ] Add `checkIntervalMs` field to `TestJobData` type
- [ ] Update `test-handler.ts` to use configurable check interval
- [ ] Set default check interval to 200ms

### Step 4: Verify and Document

- [ ] Run full test suite: `pnpm test`
- [ ] Verify 176/176 passing
- [ ] Update test documentation
- [ ] Commit changes with descriptive message

---

## üîß Code Changes Required

### File 1: `/tests/integration/job-cancellation.test.ts`

**Change 1: Reduce delays**

```typescript
// Line 194: Scenario 1
delayMs: 3000, // Was: 15000

// Line 245: Scenario 2
delayMs: 3000, // Was: 10000

// Line 353: Scenario 5
delayMs: 3000, // Was: 15000
```

**Change 2: Update afterEach**

```typescript
afterEach(async () => {
  // Wait for active jobs before cleanup
  await waitForActiveJobs(10000);
  await cleanupAllJobs();
  await cleanupJobStatusDB();
});
```

### File 2: `/tests/fixtures.ts`

**Add Smart Cleanup Utility**

```typescript
/**
 * Wait for all active jobs to complete before cleanup
 * Prevents "Missing key for job" errors
 */
export async function waitForActiveJobs(timeout: number = 10000): Promise<void> {
  const queue = getQueue();
  const startTime = Date.now();

  while (Date.now() - startTime < timeout) {
    const [active, delayed, waiting] = await Promise.all([
      queue.getActive(),
      queue.getDelayed(),
      queue.getWaiting(),
    ]);

    const totalJobs = active.length + delayed.length + waiting.length;

    if (totalJobs === 0) {
      return; // Safe to cleanup
    }

    logger.debug('Waiting for jobs to complete', {
      active: active.length,
      delayed: delayed.length,
      waiting: waiting.length,
      elapsed: Date.now() - startTime,
    });

    await new Promise(resolve => setTimeout(resolve, 250));
  }

  logger.warn('Timeout waiting for jobs, forcing cleanup', {
    timeoutMs: timeout,
  });
}
```

### File 3: `/packages/shared-types/src/bullmq-jobs.ts`

**Add checkIntervalMs field**

```typescript
export interface TestJobData extends BaseJobData {
  jobType: JobType.TEST_JOB;
  message?: string;
  delayMs?: number;
  shouldFail?: boolean;
  checkCancellation?: boolean;
  checkIntervalMs?: number; // NEW: How often to check for cancellation (default: 500ms)
}
```

### File 4: `/src/orchestrator/handlers/test-handler.ts`

**Update cancellation check logic**

```typescript
// Around line 30
const {
  message,
  delayMs = 0,
  shouldFail = false,
  checkCancellation = false,
  checkIntervalMs = 500, // Default: check every 500ms
} = job.data;

// Around line 50
if (delayMs > 0) {
  if (checkCancellation) {
    // Check for cancellation periodically during delay
    const iterations = Math.floor(delayMs / checkIntervalMs);
    const remainingMs = delayMs % checkIntervalMs;

    for (let i = 0; i < iterations; i++) {
      await this.checkCancellation(job.id!);
      await new Promise(resolve => setTimeout(resolve, checkIntervalMs));
    }

    // Handle remaining milliseconds
    if (remainingMs > 0) {
      await this.checkCancellation(job.id!);
      await new Promise(resolve => setTimeout(resolve, remainingMs));
    }
  } else {
    await new Promise(resolve => setTimeout(resolve, delayMs));
  }
}
```

---

## üìä Expected Results

### Before Implementation

```
Test Files  16 passed | 2 failed (18)
Tests  166 passed | 10 failed | 10 skipped (186)
Duration  ~25s
Success Rate: 89%
```

### After Implementation

```
Test Files  18 passed (18)
Tests  176 passed | 10 skipped (186)
Duration  ~40-50s (slightly longer due to smart cleanup)
Success Rate: 100% ‚úÖ
```

---

## üöÄ Execution Command

```bash
# Run only affected tests during development
pnpm test tests/integration/job-cancellation.test.ts
pnpm test tests/orchestrator/worker.test.ts
pnpm test tests/integration/bullmq.test.ts

# Run full test suite for verification
pnpm test

# Check for specific error patterns
pnpm test 2>&1 | grep -E "(Missing key|not found in DB|Timeout waiting)"
```

---

## üìö Reference Documentation

- **BullMQ Testing Best Practices**: https://docs.bullmq.io/guide/testing
- **Vitest Lifecycle Hooks**: https://vitest.dev/api/#beforeall
- **Redis Job Lifecycle**: packages/course-gen-platform/docs/BULLMQ_ARCHITECTURE.md
- **Previous Task**: T044.3-FIX-OTHER-TESTS.md

---

## üéØ Success Metrics

1. **Test Pass Rate**: 100% (176/176 executable tests)
2. **Test Duration**: <60 seconds for full suite
3. **Error Count**: 0 "Missing key" errors
4. **Timeout Count**: 0 "not found in DB" errors
5. **Code Coverage**: Maintain >80% coverage

---

## üîó Related Issues

- T044.1: Current status analysis
- T044.2: Fix remaining tests (initial attempt)
- T044.3: Fix other tests (timestamp/query fixes) ‚úÖ COMPLETED
- T044.4: Not created
- **T044.5: THIS TASK** - Fix final 10 test failures

---

## üë§ Assignment

**Assigned to**: TBD
**Reviewer**: TBD
**Estimated Effort**: 2-3 hours
**Deadline**: TBD

---

## üìù Notes

- The root cause (cleanup interference) is well-understood
- Option B (shorter delays) + Option A (smart cleanup) is the fastest path to 100%
- Tests may take slightly longer (~40-50s) but will be more reliable
- Consider Option C (separate suites) for future optimization
