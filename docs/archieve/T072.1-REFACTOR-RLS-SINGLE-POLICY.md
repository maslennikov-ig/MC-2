# T072.1: Refactor RLS Policies to Single Policy Per Table

**Priority**: P2 - Medium (Performance optimization)
**Status**: ‚è≥ **PENDING**
**Created**: 2025-01-14
**Parent Task**: T072 - Consolidate RLS Policies
**Impact**: Performance - Eliminate multiple permissive policy overhead
**Estimated Effort**: 2-3 hours
**Actual Effort**: -

---

## üìã Executive Summary

T072 successfully consolidated 40 ‚Üí 19 RLS policies (-52.5%) by combining role-based policies. However, Supabase Performance Advisor identified **36 warnings** indicating that the current implementation still creates "multiple permissive policies" overhead.

**Root Cause**: Using separate `FOR SELECT` and `FOR ALL` policies causes PostgreSQL to evaluate BOTH policies for SELECT queries, even though they target different operations.

**Solution**: Refactor to single `FOR ALL` policy per table using `USING` + `WITH CHECK` clauses instead of separate policies.

**Expected Impact**:
- Policy count: 19 ‚Üí 10 (further -47% reduction)
- SELECT query performance: +10-20%
- Zero "multiple permissive policies" warnings

---

## üîç Issue Analysis

### Current Implementation (T072)

Each table has 2 policies:

```sql
-- READ policy (FOR SELECT)
CREATE POLICY "courses_read" ON courses
FOR SELECT USING (
  CASE (SELECT role FROM users WHERE id = (SELECT auth.uid()))
    WHEN 'admin' THEN organization_id IN (...)
    WHEN 'instructor' THEN organization_id IN (...)
    WHEN 'student' THEN id IN (...)
    ELSE FALSE
  END
);

-- MODIFY policy (FOR ALL)
CREATE POLICY "courses_modify" ON courses
FOR ALL USING (
  CASE (SELECT role FROM users WHERE id = (SELECT auth.uid()))
    WHEN 'admin' THEN organization_id IN (...)
    WHEN 'instructor' THEN user_id = (SELECT auth.uid())
    ELSE FALSE
  END
);
```

### PostgreSQL Behavior

When a SELECT query runs:
1. PostgreSQL evaluates `courses_read` policy (FOR SELECT)
2. PostgreSQL evaluates `courses_modify` policy (FOR ALL applies to SELECT too)
3. Results are combined with OR semantics

**Problem**: Both policies are permissive, so PostgreSQL must evaluate BOTH, creating the exact overhead we tried to eliminate in T072.

### Supabase Performance Advisor Output

```
36 warnings across 9 tables:
- courses: 4 warnings (admin, instructor, student, anon roles)
- sections: 4 warnings
- lessons: 4 warnings
- lesson_content: 4 warnings
- file_catalog: 4 warnings
- course_enrollments: 4 warnings
- organizations: 4 warnings
- users: 4 warnings
- job_status: 4 warnings
```

Each table √ó 4 PostgreSQL roles = 36 total warnings

---

## üí° Proposed Solution

### Pattern: Single FOR ALL Policy with USING + WITH CHECK

```sql
-- Single policy with separate SELECT and MODIFY logic
CREATE POLICY "courses_all" ON courses
FOR ALL
USING (
  -- SELECT logic: Who can READ rows
  CASE (SELECT role FROM users WHERE id = (SELECT auth.uid()))
    WHEN 'admin' THEN
      organization_id IN (
        SELECT organization_id FROM users WHERE id = (SELECT auth.uid())
      )
    WHEN 'instructor' THEN
      organization_id IN (
        SELECT organization_id FROM users WHERE id = (SELECT auth.uid())
      )
    WHEN 'student' THEN
      id IN (
        SELECT course_id FROM course_enrollments
        WHERE user_id = (SELECT auth.uid()) AND status = 'active'
      )
    ELSE FALSE
  END
)
WITH CHECK (
  -- MODIFY logic: Who can INSERT/UPDATE/DELETE rows
  CASE (SELECT role FROM users WHERE id = (SELECT auth.uid()))
    WHEN 'admin' THEN
      organization_id IN (
        SELECT organization_id FROM users WHERE id = (SELECT auth.uid())
      )
    WHEN 'instructor' THEN
      user_id = (SELECT auth.uid())
    ELSE FALSE
  END
);

COMMENT ON POLICY "courses_all" ON courses IS
'Unified policy: USING for SELECT, WITH CHECK for INSERT/UPDATE/DELETE. Admin full org access, Instructor own courses, Student enrolled courses (read-only).';
```

### Key Differences from T072

| Aspect | T072 (Current) | T072.1 (Proposed) |
|--------|----------------|-------------------|
| Policies per table | 2 (`_read`, `_modify`) | 1 (`_all`) |
| SELECT evaluation | 2 policies (read + modify) | 1 policy (USING clause) |
| MODIFY evaluation | 1 policy (modify only) | 1 policy (WITH CHECK clause) |
| Permissive policy warnings | 36 warnings | 0 warnings |
| Performance overhead | EXISTS (2 policy checks) | MINIMAL (1 policy check) |

### Why This Works

**PostgreSQL Policy Semantics**:
- `FOR ALL` applies to all operations (SELECT, INSERT, UPDATE, DELETE)
- `USING` clause: Controls which rows are VISIBLE (SELECT) and which can be MODIFIED
- `WITH CHECK` clause: Controls which rows can be INSERTED or UPDATED
- When only `USING` is specified: `WITH CHECK` defaults to `USING` (which is why T072 had issues)
- When both specified: SELECT uses `USING` only, MODIFY uses both

**Result**: Single policy evaluation per query instead of multiple.

---

## üéØ Implementation Plan

### Step 1: Backup Current Policies (15 min)

```sql
-- Export current policies to backup file
SELECT
  schemaname,
  tablename,
  policyname,
  pg_get_policydef(oid) AS policy_definition
FROM pg_policies
JOIN pg_policy ON pg_policies.policyname = pg_policy.polname
WHERE schemaname = 'public'
ORDER BY tablename, policyname;
```

Save output to: `packages/course-gen-platform/supabase/backups/20250114_policies_before_t072.1.sql`

### Step 2: Create Migration File (1-2 hours)

File: `packages/course-gen-platform/supabase/migrations/20250114_refactor_rls_single_policy.sql`

**Structure**:

```sql
-- =============================================================================
-- Migration: Refactor RLS Policies to Single Policy Per Table
--
-- Parent: T072 - Consolidate RLS Policies
-- Issue: 36 "multiple permissive policies" warnings from Supabase Advisor
-- Solution: Replace 2 policies (_read + _modify) with 1 policy (_all)
--
-- Before: 19 policies (2 per table)
-- After: 10 policies (1 per table) + job_status exception (2 policies)
--
-- Performance Impact:
--   - SELECT queries: +10-20% (single policy evaluation)
--   - INSERT/UPDATE/DELETE: Same or better
--   - Zero permissive policy warnings
--
-- Reference: T072_IMPLEMENTATION_SUMMARY.md
-- =============================================================================

-- =============================================================================
-- COURSES TABLE (2 policies ‚Üí 1 policy)
-- =============================================================================

-- Drop existing policies from T072
DROP POLICY IF EXISTS "courses_read" ON courses;
DROP POLICY IF EXISTS "courses_modify" ON courses;

-- Create unified policy
CREATE POLICY "courses_all" ON courses
FOR ALL
USING (
  -- SELECT: Who can READ rows
  CASE (SELECT role FROM users WHERE id = (SELECT auth.uid()))
    WHEN 'admin' THEN
      organization_id IN (
        SELECT organization_id FROM users WHERE id = (SELECT auth.uid())
      )
    WHEN 'instructor' THEN
      organization_id IN (
        SELECT organization_id FROM users WHERE id = (SELECT auth.uid())
      )
    WHEN 'student' THEN
      id IN (
        SELECT course_id FROM course_enrollments
        WHERE user_id = (SELECT auth.uid()) AND status = 'active'
      )
    ELSE FALSE
  END
)
WITH CHECK (
  -- MODIFY: Who can INSERT/UPDATE/DELETE rows
  CASE (SELECT role FROM users WHERE id = (SELECT auth.uid()))
    WHEN 'admin' THEN
      organization_id IN (
        SELECT organization_id FROM users WHERE id = (SELECT auth.uid())
      )
    WHEN 'instructor' THEN
      user_id = (SELECT auth.uid())
    ELSE FALSE
  END
);

COMMENT ON POLICY "courses_all" ON courses IS
'Unified policy: USING for SELECT (admin/instructor see org, student sees enrolled), WITH CHECK for MODIFY (admin full org, instructor own only).';

-- =============================================================================
-- SECTIONS TABLE (2 policies ‚Üí 1 policy)
-- =============================================================================

DROP POLICY IF EXISTS "sections_read" ON sections;
DROP POLICY IF EXISTS "sections_modify" ON sections;

CREATE POLICY "sections_all" ON sections
FOR ALL
USING (
  CASE (SELECT role FROM users WHERE id = (SELECT auth.uid()))
    WHEN 'admin' THEN
      course_id IN (
        SELECT id FROM courses
        WHERE organization_id IN (
          SELECT organization_id FROM users WHERE id = (SELECT auth.uid())
        )
      )
    WHEN 'instructor' THEN
      course_id IN (
        SELECT id FROM courses
        WHERE organization_id IN (
          SELECT organization_id FROM users WHERE id = (SELECT auth.uid())
        )
      )
    WHEN 'student' THEN
      course_id IN (
        SELECT course_id FROM course_enrollments
        WHERE user_id = (SELECT auth.uid()) AND status = 'active'
      )
    ELSE FALSE
  END
)
WITH CHECK (
  CASE (SELECT role FROM users WHERE id = (SELECT auth.uid()))
    WHEN 'admin' THEN
      course_id IN (
        SELECT id FROM courses
        WHERE organization_id IN (
          SELECT organization_id FROM users WHERE id = (SELECT auth.uid())
        )
      )
    WHEN 'instructor' THEN
      course_id IN (
        SELECT id FROM courses WHERE user_id = (SELECT auth.uid())
      )
    ELSE FALSE
  END
);

COMMENT ON POLICY "sections_all" ON sections IS
'Unified policy: Sections follow course access (via course_id foreign key).';

-- =============================================================================
-- ... (Continue for remaining 7 tables)
-- =============================================================================

-- LESSONS, LESSON_CONTENT, FILE_CATALOG, COURSE_ENROLLMENTS,
-- ORGANIZATIONS, USERS, JOB_STATUS

-- =============================================================================
-- Verification: Check policy count reduction
-- =============================================================================

DO $$
DECLARE
  v_old_count INTEGER := 19;  -- From T072
  v_new_count INTEGER;
BEGIN
  SELECT COUNT(*) INTO v_new_count
  FROM pg_policies
  WHERE schemaname = 'public';

  RAISE NOTICE 'Policy count: % ‚Üí % (reduction: %)',
    v_old_count, v_new_count, v_old_count - v_new_count;

  IF v_new_count > 12 THEN
    RAISE WARNING 'Expected ~10 policies after refactoring, found %', v_new_count;
  END IF;
END $$;
```

### Step 3: Test Migration (30 min)

```bash
# Apply migration
cd packages/course-gen-platform
pnpm supabase db push

# Verify policy count
pnpm supabase db dump --schema-only | grep "CREATE POLICY" | wc -l
# Expected: ~10 policies

# Run full test suite
pnpm test

# Check Supabase Performance Advisor
# Expected: 0 "multiple permissive policies" warnings
```

### Step 4: Validate Performance (30 min)

```sql
-- Benchmark SELECT query performance
EXPLAIN ANALYZE
SELECT * FROM courses
WHERE status = 'published'
LIMIT 10;

-- Check policy evaluation count in plan
-- Before T072.1: Should see 2 policy checks
-- After T072.1: Should see 1 policy check

-- Run same query 100 times and measure average time
```

---

## üìä Impact Analysis

### Policy Count Reduction

| Stage | Policy Count | Change |
|-------|--------------|--------|
| Before T072 | 40 | Baseline |
| After T072 | 19 | -52.5% |
| After T072.1 | 10 | -75% total, -47% from T072 |

### Performance Improvement

**SELECT Queries** (main benefit):
- T072: 2 policy evaluations (read + modify)
- T072.1: 1 policy evaluation (USING clause only)
- Expected: +10-20% performance

**INSERT/UPDATE/DELETE Queries**:
- T072: 1 policy evaluation (modify only)
- T072.1: 1 policy evaluation (USING + WITH CHECK)
- Expected: Same or slightly better (clearer semantics)

### Advisor Warnings

| Metric | Before T072.1 | After T072.1 |
|--------|---------------|--------------|
| Multiple permissive policy warnings | 36 | 0 |
| Tables affected | 9 | 0 |
| Roles affected per table | 4 | 0 |

---

## ‚úÖ Acceptance Criteria

### Code Quality
- [ ] All 9 tables have single unified policy (1 per table)
- [ ] Each policy has both USING and WITH CHECK clauses
- [ ] SELECT logic in USING clause matches T072 _read policies
- [ ] MODIFY logic in WITH CHECK clause matches T072 _modify policies
- [ ] Each policy has descriptive COMMENT explaining both clauses

### Testing
- [ ] All 270 tests pass after migration
- [ ] Manual testing with admin/instructor/student roles
- [ ] SELECT queries show single policy evaluation in EXPLAIN ANALYZE
- [ ] INSERT/UPDATE/DELETE operations work correctly
- [ ] No functional regressions from T072

### Performance
- [ ] Supabase Performance Advisor shows 0 "multiple permissive policies" warnings
- [ ] SELECT query performance improved by 10-20% (measure with EXPLAIN ANALYZE)
- [ ] Policy count reduced from 19 to ~10

### Documentation
- [ ] Migration includes clear comments explaining USING vs WITH CHECK
- [ ] Create T072.1_IMPLEMENTATION_SUMMARY.md
- [ ] Update T072_IMPLEMENTATION_SUMMARY.md with follow-up completion
- [ ] Document rollback procedure

---

## üîÑ Rollback Plan

If issues arise after deployment:

```sql
-- Restore T072 policies from backup
\i supabase/backups/20250114_policies_before_t072.1.sql

-- OR restore from T072 migration
\i supabase/migrations/20250114_consolidate_rls_policies.sql

-- Verify restoration
SELECT COUNT(*) FROM pg_policies WHERE schemaname = 'public';
-- Expected: 19 policies
```

---

## ‚ö†Ô∏è Important Notes

### Why This Was Not Done in T072

**Reason**: T072 focused on consolidating ROLE-based policies (admin/instructor/student) into single policies per role. The FOR SELECT + FOR ALL pattern seemed correct at the time.

**Discovery**: Supabase Performance Advisor revealed that FOR ALL applies to SELECT queries too, creating the multiple permissive policy issue.

**Lesson**: Always run advisors after major RLS changes to catch subtle issues.

### PostgreSQL Policy Semantics Reference

From PostgreSQL docs:

> "Policies can be applied for specific commands or for all commands. If multiple policies are applied to a query, they are combined using OR (for permissive policies) or AND (for restrictive policies)."

> "The USING expression is applied for SELECT, UPDATE, DELETE, and as a WITH CHECK constraint for INSERT/UPDATE if no explicit WITH CHECK is provided."

**Key Insight**: FOR ALL without explicit WITH CHECK uses USING for both SELECT and MODIFY, causing duplicate evaluation.

### Exception: job_status Table

**Decision**: Keep 2 policies for job_status due to complex 8-role authorization matrix.

**Rationale**:
- Original: 8 policies ‚Üí 2 policies in T072 (already consolidated)
- Consolidating to 1 policy would create extremely complex CASE statement
- Performance impact minimal (2 policies acceptable for this table)
- Maintainability > perfect policy count

---

## üîó Related Tasks

- **T068**: Fix RLS InitPlan Performance - Related RLS optimization (auth.uid() wrapping)
- **T072**: Consolidate RLS Policies - Parent task (40 ‚Üí 19 policies)
- **T073**: Review Unused Indexes - Related database optimization

---

## üìö References

### PostgreSQL Documentation
- [Row Security Policies](https://www.postgresql.org/docs/current/ddl-rowsecurity.html)
- [CREATE POLICY](https://www.postgresql.org/docs/current/sql-createpolicy.html)
- [Policy USING vs WITH CHECK](https://www.postgresql.org/docs/current/sql-createpolicy.html#SQL-CREATEPOLICY-EXAMPLES)

### Supabase Documentation
- [Database Linter - Multiple Permissive Policies](https://supabase.com/docs/guides/database/database-linter)
- [RLS Performance Best Practices](https://supabase.com/docs/guides/database/postgres/row-level-security#performance)
- [RLS Performance and Best Practices - Troubleshooting](https://supabase.com/docs/guides/troubleshooting/rls-performance-and-best-practices)

### Community Resources
- [Optimizing PostgreSQL RLS for Performance - Scott Pierce](https://scottpierce.dev/posts/optimizing-postgres-rls/)
- [PostgreSQL RLS Implementation Guide - Permit.io](https://www.permit.io/blog/postgres-rls-implementation-guide)
- [AWS Prescriptive Guidance - RLS Recommendations](https://docs.aws.amazon.com/prescriptive-guidance/latest/saas-multitenant-managed-postgresql/rls.html)

### Related Documentation
- `T072_IMPLEMENTATION_SUMMARY.md` - Parent task completion report
- `T068-FIX-RLS-INITPLAN-PERFORMANCE.md` - Related RLS optimization

---

## üî¨ Additional Research Findings (2025-01-14)

### Critical Performance Insights

**From PostgreSQL 18 Documentation:**
> "Policy expression will be evaluated for each row prior to any conditions or functions coming from the user's query."

This means RLS policies are evaluated **before** user query filters, making optimization crucial for large datasets.

**Multiple Policy Evaluation Order:**
> "Executing the policies from least to most expensive can have a dramatic effect on query speed, since there is the possibility that the more expensive policies will not be executed (when a cheaper policy returns true)."

With permissive policies combined via OR, PostgreSQL may short-circuit evaluation if a cheap policy passes first.

### Best Practices Validated

‚úÖ **Already Implemented in T072:**
1. ‚úÖ Function wrapping: `(SELECT auth.uid())` pattern for initPlan optimization
2. ‚úÖ Role specification: Policies use `TO` clause (implicit via CASE on role)
3. ‚úÖ Avoiding direct joins: Using `IN (SELECT ...)` instead of table joins

‚ö†Ô∏è **Additional Optimizations to Verify:**

1. **Index Coverage Check**
   ```sql
   -- Verify indexes exist for all columns used in policies:
   SELECT
     schemaname, tablename, indexname, indexdef
   FROM pg_indexes
   WHERE schemaname = 'public'
     AND tablename IN ('courses', 'sections', 'lessons', 'lesson_content',
                       'course_enrollments', 'organizations', 'users', 'file_catalog', 'job_status')
   ORDER BY tablename, indexname;
   ```

   **Required indexes:**
   - `courses`: organization_id, user_id
   - `sections`: course_id
   - `lessons`: section_id
   - `lesson_content`: lesson_id
   - `course_enrollments`: user_id, course_id, status
   - `users`: id, organization_id
   - `file_catalog`: organization_id, course_id
   - `job_status`: organization_id, user_id, course_id

2. **Explicit Client-Side Filters**
   Even with RLS, adding explicit filters to queries improves performance:
   ```typescript
   // BEFORE (relies on RLS only)
   const { data } = await supabase.from('courses').select('*');

   // AFTER (explicit filter + RLS)
   const { data } = await supabase
     .from('courses')
     .select('*')
     .eq('organization_id', userOrgId); // Helps query planner
   ```

3. **SECURITY DEFINER Functions (Future Optimization)**
   For complex checks involving multiple tables, consider security definer functions:
   ```sql
   CREATE FUNCTION check_course_access(course_id_param uuid)
   RETURNS boolean
   LANGUAGE plpgsql
   SECURITY DEFINER
   AS $$
   BEGIN
     -- This bypasses RLS on joined tables
     RETURN EXISTS (
       SELECT 1 FROM courses
       WHERE id = course_id_param
         AND organization_id = (SELECT organization_id FROM users WHERE id = auth.uid())
     );
   END;
   $$;
   ```

### Performance Benchmarking Methodology

**Before/After Comparison:**
```sql
-- 1. Set up test role
SET ROLE authenticated;
SET request.jwt.claims TO '{"role":"instructor", "sub":"<test-uuid>", "organization_id":"<org-uuid>"}';

-- 2. Run EXPLAIN ANALYZE multiple times
EXPLAIN (ANALYZE, BUFFERS, TIMING)
SELECT * FROM courses WHERE status = 'published' LIMIT 10;

-- 3. Look for:
--    - Number of "SubPlan" nodes (should decrease from 2 to 1)
--    - "Execution Time" (should improve by 10-20%)
--    - "Shared Hit Blocks" (cache usage)

-- 4. Run 100 times for statistical significance
SELECT pg_sleep(0.1);  -- between runs
-- Record avg/min/max execution times

-- 5. Reset role
RESET ROLE;
```

### Validation Checklist

Before declaring T072.1 complete:
- [ ] All indexes verified present (see query above)
- [ ] EXPLAIN ANALYZE shows single policy evaluation
- [ ] Performance improvement measured (10-20% for SELECT)
- [ ] Zero "multiple permissive policies" warnings
- [ ] Zero "auth_rls_initplan" warnings
- [ ] All 270 tests pass
- [ ] Manual testing with all roles (admin/instructor/student)

---

## üöÄ Next Steps

1. **Immediate**:
   - Review this task document
   - Backup current policies (Step 1)
   - Create migration file (Step 2)
   - Test in development (Step 3)

2. **Testing**:
   - Run full test suite (270 tests)
   - Manual testing with all 3 roles
   - Performance benchmarking (EXPLAIN ANALYZE)
   - Advisor check (verify 0 warnings)

3. **Documentation**:
   - Create T072.1_IMPLEMENTATION_SUMMARY.md
   - Update T072_IMPLEMENTATION_SUMMARY.md
   - Add to project maintenance notes

4. **Long-term**:
   - Monitor SELECT query performance in production
   - Document pattern for future RLS policies
   - Add to team best practices guide

---

**Created By**: Claude Code (Anthropic)
**Research Duration**: 30 minutes (discovered during T072 completion)
**Priority**: P2 - Medium (Performance optimization, not critical)
**Complexity**: Medium (Straightforward refactoring, well-understood pattern)
**Estimated Effort**: 2-3 hours
**Confidence Level**: üü¢ **HIGH (95%)** - Pattern is well-documented and tested in PostgreSQL community
