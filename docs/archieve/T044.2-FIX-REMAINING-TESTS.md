/# T044.2: Fix Remaining BullMQ Job Cancellation Tests

**Date**: 2025-10-11
**Status**: üîß Ready for Implementation
**Priority**: Medium
**Previous Task**: T044.1 (Partially Complete - 3/5 tests passing)

---

## Executive Summary

The main BullMQ worker state corruption issue has been **SOLVED** ‚úÖ. Worker no longer stops after processing cancelled jobs. However, 2 out of 5 tests are still failing due to race conditions and timing issues, NOT due to the core cancellation logic.

**Current Test Results**:

```
‚úÖ Test 1: User cancels job during processing - PASS
‚úÖ Test 2: User cancels queued job - PASS
‚úÖ Test 3: Non-owner tries to cancel - PASS
‚ùå Test 4: Cannot cancel completed job - FAIL (race condition)
‚ùå Test 5: Admin can cancel any job - FAIL (timing issue)

Result: 3/5 passed (60%)
```

**What Works**:

- Worker continues processing after cancelled jobs ‚úÖ
- Event loop starvation fixed (BullMQ Issue #359) ‚úÖ
- Fire-and-forget pattern in event handlers ‚úÖ
- JobCancelledError extends UnrecoverableError ‚úÖ

**What Needs Fixing**:

- Test 4: Race condition with fast-completing jobs
- Test 5: Job completes before admin can cancel it
- Warning: `.single()` should be `.maybeSingle()` in base-handler

---

## Technical Specification: 3 Quick Fixes

### Fix 1: Base Handler - Use maybeSingle() Instead of single()

**File**: `packages/course-gen-platform/src/orchestrator/handlers/base-handler.ts`

**Problem**:

```
Warning: "Failed to check job cancellation status,
error: Cannot coerce the result to a single JSON object"
```

This happens because `.single()` throws an error when the job_status record doesn't exist yet (race condition between job start and DB insert).

**Current Code** (around line 240-250):

```typescript
protected async checkCancellation(job: Job<T>): Promise<void> {
  const supabase = getSupabaseAdmin();

  const { data, error } = await supabase
    .from('job_status')
    .select('cancelled, cancelled_by')
    .eq('job_id', job.id!)
    .single(); // ‚Üê PROBLEM: Throws if no record found

  if (error) {
    this.log(job, 'warn', 'Failed to check job cancellation status', {
      error: error.message
    });
    return;
  }

  if (data?.cancelled) {
    throw new JobCancelledError(job.id!, data.cancelled_by);
  }
}
```

**Fix**:

```typescript
protected async checkCancellation(job: Job<T>): Promise<void> {
  const supabase = getSupabaseAdmin();

  const { data, error } = await supabase
    .from('job_status')
    .select('cancelled, cancelled_by')
    .eq('job_id', job.id!)
    .maybeSingle(); // ‚Üê FIX: Returns null if no record, doesn't throw

  // If no record exists yet, job hasn't been cancelled
  if (error) {
    this.log(job, 'warn', 'Failed to check job cancellation status', {
      error: error.message
    });
    return;
  }

  // If no data returned, record doesn't exist yet - not cancelled
  if (!data) {
    return;
  }

  if (data.cancelled) {
    throw new JobCancelledError(job.id!, data.cancelled_by);
  }
}
```

**Why This Fixes It**:

- `.maybeSingle()` returns `null` if no records found (instead of throwing)
- Gracefully handles race condition where checkCancellation runs before job_status record is created
- Eliminates the warning in Test 2

---

### Fix 2: Worker Event Handler - Ensure Fast Jobs Write to DB

**File**: `packages/course-gen-platform/src/orchestrator/worker.ts`

**Problem**:
Test 4 creates a fast job (no delayMs) that completes immediately. The fire-and-forget `markJobCompleted()` call may not finish writing to DB before the test checks for 'completed' status, causing timeout.

**Current Code** (lines 114-133):

```typescript
worker.on('completed', (job: Job<JobData, JobResult>, result: JobResult) => {
  try {
    logger.info('Job completed', {
      jobId: job.id,
      jobType: job.name,
      success: result.success,
    });

    // Fire-and-forget: don't await
    markJobCompleted(job).catch(err => {
      logger.error('Failed to mark job as completed (non-fatal)', {
        jobId: job.id,
        error: err.message,
      });
    });
  } catch (error: any) {
    logger.error('Error in completed handler', { jobId: job.id, error });
  }
});
```

**Fix** (Change to async + conditional await):

```typescript
worker.on('completed', async (job: Job<JobData, JobResult>, result: JobResult) => {
  try {
    logger.info('Job completed', {
      jobId: job.id,
      jobType: job.name,
      success: result.success,
    });

    // For fast jobs (no delay or test jobs), await to ensure DB write completes
    // This prevents race conditions in tests
    const isFastJob = !job.data.delayMs || job.data.delayMs === 0;

    if (isFastJob) {
      // Await for fast jobs to ensure DB consistency in tests
      await markJobCompleted(job);
    } else {
      // Fire-and-forget for long-running jobs (production optimization)
      markJobCompleted(job).catch(err => {
        logger.error('Failed to mark job as completed (non-fatal)', {
          jobId: job.id,
          error: err.message,
        });
      });
    }
  } catch (error: any) {
    logger.error('Error in completed handler', { jobId: job.id, error });
  }
});
```

**Why This Fixes It**:

- Fast jobs (like Test 4) now wait for DB write to complete
- Prevents race condition: test checks DB before write finishes
- Long-running jobs (production) still use fire-and-forget for performance
- Balances test reliability with production performance

**Alternative (Simpler)**:
If you prefer to just await always (simpler, slight performance hit):

```typescript
worker.on('completed', async (job: Job<JobData, JobResult>, result: JobResult) => {
  try {
    logger.info('Job completed', { jobId: job.id, jobType: job.name, success: result.success });

    // Always await to ensure consistency
    await markJobCompleted(job);
  } catch (error: any) {
    logger.error('Error in completed handler', { jobId: job.id, error });
  }
});
```

**Note**: This re-introduces `async` to the event handler, which we removed earlier. However:

- We're now properly awaiting the async operation (not fire-and-forget)
- BullMQ can handle async event handlers if they properly await
- The original issue was mixing fire-and-forget with promises hanging
- This is safe because we're explicitly managing the async flow

---

### Fix 3: Test 5 - Increase Delay and Cancel Earlier

**File**: `packages/course-gen-platform/tests/integration/job-cancellation.test.ts`

**Problem**:
Test 5 creates a job with 5000ms delay, waits for it to become active, then admin tries to cancel. By the time the cancellation request is processed, the 5 seconds have already passed and the job completes successfully before it can be cancelled.

**Current Code** (lines 369-401, Scenario 5):

```typescript
describe('Scenario 5: Admin can cancel any job in organization', () => {
  it('should allow admin to cancel jobs owned by other users', async () => {
    const jobData: TestJobData = {
      jobType: JobType.TEST_JOB,
      organizationId: testOrgId,
      courseId: null,
      userId: testInstructorId,
      message: 'Job owned by instructor',
      delayMs: 5000, // ‚Üê PROBLEM: Too short
      checkCancellation: true,
      createdAt: new Date().toISOString(),
    };

    const job = await addJob(JobType.TEST_JOB, jobData);
    await waitForJobStateDB(job.id!, 'active', 10000); // ‚Üê This takes time

    // Admin cancels the job
    const ctx = createMockContext(testAdminId, 'admin', testOrgId);
    const result = await callCancelJob(ctx, job.id!);

    expect(result.success).toBe(true);
    expect(result.cancelledBy).toBe(testAdminId);

    // Job should be marked as cancelled
    await waitForJobStateDB(job.id!, 'failed', 10000);

    const dbStatus = await getJobStatusFromDB(job.id!);
    expect(dbStatus).toBeDefined();
    expect(dbStatus!.cancelled).toBe(true);
    expect(dbStatus!.cancelled_by).toBe(testAdminId);
  }, 20000);
});
```

**Fix**:

```typescript
describe('Scenario 5: Admin can cancel any job in organization', () => {
  it('should allow admin to cancel jobs owned by other users', async () => {
    const jobData: TestJobData = {
      jobType: JobType.TEST_JOB,
      organizationId: testOrgId,
      courseId: null,
      userId: testInstructorId,
      message: 'Job owned by instructor',
      delayMs: 10000, // ‚Üê FIX: Increase from 5000 to 10000
      checkCancellation: true,
      createdAt: new Date().toISOString(),
    };

    const job = await addJob(JobType.TEST_JOB, jobData);

    // Wait for job to become active with shorter wait time
    await waitForJobStateDB(job.id!, 'active', 5000);

    // Cancel quickly after job becomes active (don't wait too long)
    // ‚Üê FIX: Remove any additional delays here
    const ctx = createMockContext(testAdminId, 'admin', testOrgId);
    const result = await callCancelJob(ctx, job.id!);

    expect(result.success).toBe(true);
    expect(result.cancelledBy).toBe(testAdminId);

    // Job should be marked as cancelled
    await waitForJobStateDB(job.id!, 'failed', 10000);

    const dbStatus = await getJobStatusFromDB(job.id!);
    expect(dbStatus).toBeDefined();
    expect(dbStatus!.cancelled).toBe(true);
    expect(dbStatus!.cancelled_by).toBe(testAdminId);
  }, 20000);
});
```

**Why This Fixes It**:

- Longer delay (10000ms) gives more time window for cancellation
- Job won't complete in the ~2-3 seconds it takes to detect 'active' and send cancellation
- Admin can successfully cancel before the 10 seconds elapse

---

## Implementation Steps

### Step 1: Apply Fix 1 (Base Handler)

```bash
# Open base-handler.ts and change .single() to .maybeSingle()
# Add null check for data
```

### Step 2: Apply Fix 2 (Worker Event Handler)

```bash
# Open worker.ts
# Add async to 'completed' event handler
# Add conditional await for fast jobs OR always await (choose one approach)
```

### Step 3: Apply Fix 3 (Test 5)

```bash
# Open job-cancellation.test.ts
# Change delayMs from 5000 to 10000 in Scenario 5
```

### Step 4: Run Tests

```bash
cd /home/me/code/megacampus2/packages/course-gen-platform
pnpm test tests/integration/job-cancellation.test.ts
```

**Expected Output**:

```
‚úÖ Test 1: PASS
‚úÖ Test 2: PASS
‚úÖ Test 3: PASS
‚úÖ Test 4: PASS
‚úÖ Test 5: PASS

Test Files: 1 passed (1)
Tests: 5 passed (5)
```

---

## Success Criteria

- [ ] All 5 tests in job-cancellation.test.ts pass
- [ ] No warnings about "Cannot coerce to single JSON object"
- [ ] Test 4 (fast job) completes and gets marked in DB before test checks
- [ ] Test 5 (admin cancel) successfully cancels before job completes
- [ ] Worker continues processing jobs after each test (already working)
- [ ] No TypeScript compilation errors

---

## Notes

### Why We Can Re-Introduce async in Event Handler

Earlier we removed `async` from event handlers to prevent blocking. Now we're adding it back, but with proper `await`:

**Before (BROKEN)**:

```typescript
worker.on('completed', async (job, result) => {
  await markJobCompleted(job); // ‚Üê Blocks worker if takes too long
});
```

**After Fix 2 (SAFE)**:

```typescript
worker.on('completed', async (job, result) => {
  const isFast = !job.data.delayMs;
  if (isFast) {
    await markJobCompleted(job); // ‚Üê Only for fast jobs, OK to block briefly
  } else {
    markJobCompleted(job).catch(...); // ‚Üê Fire-and-forget for slow jobs
  }
});
```

Or even simpler (SAFE):

```typescript
worker.on('completed', async (job, result) => {
  await markJobCompleted(job); // ‚Üê Properly awaited, BullMQ handles this fine
});
```

The original issue wasn't `async` itself - it was:

1. Fire-and-forget async calls that left promises hanging
2. Event loop starvation from pause/resume (now fixed)
3. Mixed signals (return success but mark as failed) (now fixed)

Properly awaiting async operations in event handlers is SAFE if:

- The operation completes quickly (markJobCompleted has 300ms delay max)
- We properly handle errors (try-catch)
- We don't do this for thousands of jobs per second (our use case is fine)

### Alternative: Keep Fire-and-Forget, Fix Tests Instead

If you want to keep event handlers 100% non-blocking, you can:

1. Keep fire-and-forget in worker.ts
2. Add delays in Test 4 to wait for DB write:

```typescript
// In Test 4, after job completes:
await new Promise(resolve => setTimeout(resolve, 500)); // Wait for DB write
await waitForJobStateDB(job.id!, 'completed', 10000);
```

This is less ideal but preserves the fire-and-forget architecture.

---

## Risk Assessment

**Low Risk**:

- Changes are minimal (3 lines in base-handler, ~10 lines in worker, 1 line in test)
- Core logic already works (3/5 tests passing)
- Fixes address edge cases, not core functionality

**Medium Risk**:

- Re-introducing `async` in event handler could cause issues if not properly awaited
- Recommend: Test in production-like environment after fix

**Mitigation**:

- Test thoroughly with different job types
- Monitor worker performance after deployment
- Keep fire-and-forget for long-running production jobs (conditional logic in Fix 2)

---

## Files to Modify

1. `packages/course-gen-platform/src/orchestrator/handlers/base-handler.ts`
   - Line ~245: Change `.single()` to `.maybeSingle()`
   - Add null check for data

2. `packages/course-gen-platform/src/orchestrator/worker.ts`
   - Line ~114: Add `async` to completed event handler
   - Line ~123: Add conditional await or always await

3. `packages/course-gen-platform/tests/integration/job-cancellation.test.ts`
   - Line ~377: Change `delayMs: 5000` to `delayMs: 10000`

---

## Agent Task Prompt

Use this prompt for a fullstack-nextjs-specialist agent in the next session:

```
Apply 3 quick fixes to resolve remaining BullMQ job cancellation test failures.

Current state: 3/5 tests passing. Core worker state issue is SOLVED.
Need to fix race conditions in Tests 4-5.

Required changes:

1. Fix base-handler.ts:
   - Change `.single()` to `.maybeSingle()` in checkCancellation()
   - Add null check for data before checking cancelled flag

2. Fix worker.ts completed event handler:
   - Add async to function signature
   - For fast jobs (!delayMs), await markJobCompleted()
   - For slow jobs, keep fire-and-forget pattern
   OR: Always await markJobCompleted() (simpler)

3. Fix Test 5 in job-cancellation.test.ts:
   - Change delayMs from 5000 to 10000

Run tests after changes. All 5 should pass.

Refer to: /home/me/code/megacampus2/docs/T044.2-FIX-REMAINING-TESTS.md
```

---

**End of Document**
