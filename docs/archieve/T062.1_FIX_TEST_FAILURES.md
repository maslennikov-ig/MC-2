# T062.1: Fix BullMQ Worker Integration in tRPC Server Tests

**Parent Task**: T062 - Verify tRPC server with acceptance tests
**Status**: âœ… Complete
**Priority**: High (blocking 100% test pass rate)
**Assignee**: integration-tester agent
**Created**: 2025-10-13
**Completed**: 2025-10-13

---

## ðŸ“Š Current Status

**Test Results**: 11/16 passing (68.75%)
**Failing Tests**: 5 (31.25%)

### âœ… Passing Tests (11)

1. Server starts and responds to test procedure (2/2)
2. Type-safe responses (2/2)
3. Authentication required - 401 errors (3/3)
4. Role authorization - 403 errors (2/2)
5. Input validation - 400 errors (1/1)
6. Error message quality (1/1)

### âŒ Failing Tests (5)

| Test | Scenario                                  | Error                                   |
| ---- | ----------------------------------------- | --------------------------------------- |
| 1    | Extract user context from JWT             | `PGRST116` - 0 rows found in job_status |
| 2    | Use current user context from DB          | `jobStatus?.user_id` is undefined       |
| 3    | Instructor creates course successfully    | `PGRST116` - 0 rows found in job_status |
| 4    | Concurrent requests from multiple clients | `job1?.user_id` is undefined            |
| 5    | Isolate requests by organization context  | `job1?.organization_id` is undefined    |

---

## ðŸ” Root Cause Analysis

### Problem

The tRPC server tests create BullMQ jobs via the API but **do not start the BullMQ worker** to process them.

**Execution Flow (Current - Broken)**:

```
1. Test calls: client.generation.initiate.mutate({ courseId })
2. tRPC API creates job in Redis queue âœ…
3. Returns jobId to test âœ…
4. Test queries database: SELECT * FROM job_status WHERE job_id = ? âŒ
5. ERROR: PGRST116 (0 rows) - job record doesn't exist
```

**Why job_status is empty:**

- BullMQ worker is NOT running in tests
- Worker's event handlers create job_status records:
  - `worker.on('active')` â†’ creates pending record
  - `worker.on('completed')` â†’ updates to completed
  - `worker.on('failed')` â†’ updates to failed
- Without worker, jobs sit in Redis queue but never get processed
- No database records are created

### Evidence from Test Output

```bash
stdout | tests/integration/trpc-server.test.ts
{"timestamp":"2025-10-13T09:25:33.969Z","level":"info","message":"Job added to queue","jobId":"5"...}
```

Jobs ARE being created (IDs: 5, 6, 7, 8, 9, 10, 11) but never processed.

### Comparison with Working Tests

File: `tests/integration/bullmq.test.ts` âœ…

```typescript
beforeAll(async () => {
  // ... setup ...

  // âœ… STARTS WORKER!
  worker = getWorker(1); // Single worker for predictable test execution
});

afterAll(async () => {
  // âœ… STOPS WORKER GRACEFULLY!
  await stopWorker(false);
  await closeQueue();
  await redis.quit();
});
```

File: `tests/integration/trpc-server.test.ts` âŒ

```typescript
beforeAll(async () => {
  await setupTestFixtures();
  testServer = await startTestServer();
  // âŒ MISSING: No worker started!
});

afterAll(async () => {
  await stopTestServer(testServer);
  // âŒ MISSING: No worker to stop!
});
```

---

## ðŸŽ¯ Solution

### Required Changes

**File**: `tests/integration/trpc-server.test.ts`

#### 1. Import Worker Functions

```typescript
import { getWorker, stopWorker } from '../../src/orchestrator/worker';
import { closeQueue } from '../../src/orchestrator/queue';
```

#### 2. Add Worker Variable

```typescript
describe('tRPC Server - Acceptance Tests', () => {
  let testServer: TestServer;
  let serverPort: number;
  let worker: any; // â† ADD THIS
```

#### 3. Start Worker in beforeAll

```typescript
beforeAll(async () => {
  console.log('Setting up tRPC server acceptance tests...');

  await cleanupTestFixtures();

  // Create auth users
  try {
    await createAuthUser(
      TEST_USERS.instructor1.email,
      'test-password-123',
      TEST_USERS.instructor1.id
    );
    await createAuthUser(
      TEST_USERS.instructor2.email,
      'test-password-456',
      TEST_USERS.instructor2.id
    );
    await createAuthUser(TEST_USERS.student.email, 'test-password-789', TEST_USERS.student.id);
  } catch (error) {
    console.warn('Warning: Could not create auth users:', error);
  }

  await setupTestFixtures();

  testServer = await startTestServer();
  serverPort = testServer.port;

  // âœ¨ ADD THIS: Start BullMQ worker
  worker = getWorker(1); // Single worker for predictable execution
  console.log('BullMQ worker started for test job processing');

  console.log(`Test server ready on port ${serverPort}`);
}, 30000);
```

#### 4. Stop Worker in afterAll

```typescript
afterAll(async () => {
  console.log('Tearing down tRPC server acceptance tests...');

  // âœ¨ ADD THIS: Stop worker BEFORE server
  if (worker) {
    console.log('Stopping BullMQ worker...');
    await stopWorker(false);
    await closeQueue();
  }

  // Stop server
  if (testServer) {
    await stopTestServer(testServer);
  }

  await cleanupTestFixtures();

  // Cleanup auth users
  const supabase = getSupabaseAdmin();
  try {
    const {
      data: { users },
    } = await supabase.auth.admin.listUsers();
    const testEmails = [
      TEST_USERS.instructor1.email,
      TEST_USERS.instructor2.email,
      TEST_USERS.student.email,
    ];

    for (const user of users) {
      if (user.email && testEmails.includes(user.email)) {
        await supabase.auth.admin.deleteUser(user.id);
        console.log(`Deleted auth user: ${user.email}`);
      }
    }
  } catch (error) {
    console.warn('Warning: Could not cleanup auth users:', error);
  }
}, 15000);
```

#### 5. Add Wait Helper for Job Processing (Optional but Recommended)

```typescript
/**
 * Wait for job to be processed and recorded in database
 *
 * @param jobId - BullMQ job ID
 * @param timeoutMs - Maximum wait time in milliseconds (default: 5000)
 * @returns Job status record from database
 */
async function waitForJobInDatabase(jobId: string, timeoutMs: number = 5000) {
  const startTime = Date.now();
  const supabase = getSupabaseAdmin();

  while (Date.now() - startTime < timeoutMs) {
    const { data: jobStatus } = await supabase
      .from('job_status')
      .select('*')
      .eq('job_id', jobId)
      .single();

    if (jobStatus) {
      return jobStatus;
    }

    // Wait 100ms before checking again
    await new Promise(resolve => setTimeout(resolve, 100));
  }

  throw new Error(`Timeout waiting for job ${jobId} to appear in database`);
}
```

#### 6. Update Failing Tests to Use Wait Helper

**Example** - Scenario 4, Test 1:

```typescript
it('should extract user context from valid JWT token', async () => {
  const token = await getAuthToken(TEST_USERS.instructor1.email, 'test-password-123');
  const client = createTestClient(serverPort, token);

  const courseId = TEST_COURSES.course1.id;
  const response = await client.generation.initiate.mutate({ courseId });

  expect(response).toBeDefined();
  expect(response.jobId).toBeDefined();
  expect(response.status).toBe('pending');
  expect(response.courseId).toBe(courseId);

  // âœ¨ ADD THIS: Wait for job to be processed
  const jobStatus = await waitForJobInDatabase(response.jobId, 5000);

  // Then verify job was created with correct user context
  expect(jobStatus).toBeDefined();
  expect(jobStatus.user_id).toBe(TEST_USERS.instructor1.id);
  expect(jobStatus.organization_id).toBe(TEST_USERS.instructor1.organizationId);
});
```

Apply similar changes to:

- Scenario 4, Test 2
- Scenario 6, Test 1
- Scenario 7, Test 1
- Scenario 7, Test 3

---

## ðŸ“š Best Practices from BullMQ Documentation

### From Context7 Research (289 code snippets analyzed):

1. **Worker Lifecycle Management**:

   ```typescript
   // Graceful shutdown pattern
   await worker.close();
   await connection.quit();
   ```

2. **Worker Error Handling**:

   ```typescript
   worker.on('error', err => {
     console.error('Worker error:', err);
   });
   ```

3. **Worker Event Listeners** (useful for debugging):

   ```typescript
   worker.on('completed', job => {
     console.log(`Job ${job.id} completed!`);
   });

   worker.on('failed', (job, err) => {
     console.log(`Job ${job.id} failed: ${err.message}`);
   });
   ```

4. **Graceful Shutdown with Signal Handlers**:
   ```typescript
   process.on('SIGTERM', async () => {
     await worker.close();
     process.exit(0);
   });
   ```

---

## âœ… Acceptance Criteria

### Must Pass (100%):

- [x] All 16 tests pass without errors âœ…
- [x] Job status records created in database âœ…
- [x] Worker starts gracefully before tests âœ…
- [x] Worker stops gracefully after tests âœ…
- [x] No memory leaks or hanging processes âœ…

### Verification:

```bash
pnpm test tests/integration/trpc-server.test.ts

# Expected output:
# Test Files  1 passed (1)
# Tests  16 passed (16)  â† 100% pass rate
# Duration  ~20s
```

---

## ðŸ”§ Implementation Steps

### Step 1: Update Imports (1 minute)

Add worker functions to imports at top of file.

### Step 2: Add Worker Variable (1 minute)

Declare worker variable in test suite scope.

### Step 3: Start Worker in beforeAll (2 minutes)

Add worker initialization after server starts.

### Step 4: Stop Worker in afterAll (2 minutes)

Add graceful worker shutdown before server closes.

### Step 5: Add Wait Helper Function (3 minutes)

Create `waitForJobInDatabase()` helper function.

### Step 6: Update 5 Failing Tests (10 minutes)

Add `await waitForJobInDatabase()` to each failing test.

### Step 7: Run Tests and Verify (5 minutes)

Execute test suite and confirm 16/16 passing.

**Total Estimated Time**: 25 minutes

---

## ðŸŽ¯ Expected Results

### Before Fix:

```
Test Files  1 failed (1)
Tests  5 failed | 11 passed (16)
Duration  17.22s
```

### After Fix:

```
Test Files  1 passed (1)
Tests  16 passed (16)  â† 100% âœ…
Duration  ~20s
```

### Test Output (Expected):

```
stdout | tests/integration/trpc-server.test.ts
Setting up tRPC server acceptance tests...
Created auth user for test-instructor1@megacampus.com
Created auth user for test-instructor2@megacampus.com
Created auth user for test-student@megacampus.com
Test tRPC server started on port 40536
BullMQ worker started for test job processing  â† NEW
Test server ready on port 40536

âœ“ Scenario 1: Server starts successfully (2)
âœ“ Scenario 2: Type-safe responses (2)
âœ“ Scenario 3: Authentication required (3)
âœ“ Scenario 4: JWT context extraction (2)  â† FIXED
âœ“ Scenario 5: Role authorization (2)
âœ“ Scenario 6: Instructor success (2)  â† FIXED
âœ“ Scenario 7: Multi-client authentication (3)  â† FIXED

Stopping BullMQ worker...  â† NEW
Test tRPC server stopped (port 40536)

Test Files  1 passed (1)
Tests  16 passed (16)
Duration  20.45s
```

---

## ðŸ“ Additional Notes

### Why This Fix Works

1. **Worker processes jobs**: Job status records are created
2. **Database queries succeed**: Records exist when tests query
3. **Consistent with working tests**: Uses same pattern as `bullmq.test.ts`
4. **Graceful lifecycle**: Proper startup/shutdown prevents resource leaks

### Alternative Solutions Considered

âŒ **Mock BullMQ**: Would not test real integration
âŒ **Mock database queries**: Would not validate actual data flow
âŒ **Skip failing tests**: Would reduce test coverage
âœ… **Start real worker**: Tests actual integration (CHOSEN)

### Future Improvements

1. **Worker event logging** (optional):

   ```typescript
   worker.on('completed', job => {
     console.log(`Test job ${job.id} completed`);
   });
   ```

2. **Parallel test isolation**:
   - Consider unique queue names per test file
   - Prevents interference between test suites

3. **Performance optimization**:
   - Reuse worker across tests (currently done)
   - Clean queue between tests (already implemented)

---

## ðŸ”— References

- **Parent Task**: `specs/001-stage-0-foundation/tasks.md` â†’ T062
- **Working Example**: `tests/integration/bullmq.test.ts` (T044)
- **Worker Module**: `src/orchestrator/worker.ts`
- **Queue Module**: `src/orchestrator/queue.ts`
- **BullMQ Docs**: [taskforcesh/bullmq](https://github.com/taskforcesh/bullmq) (289 code snippets)

---

**Success Metric**: 16/16 tests passing (100% pass rate) âœ…
